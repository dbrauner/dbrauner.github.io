---
layout: post
title: Como fizemos o oldRadio?
oldUrl: http://blog.zenorocha.com/post/27569632629/como-fizemos-o-oldradio
---

<p><a href="https://developer.mozilla.org/pt-BR/demos/detail/old-radio/launch" target="_blank"><img src="http://media.tumblr.com/tumblr_m6wxcmvAt21qe3219.jpg"/></a></p>

<p class="demo-download"><a href="https://developer.mozilla.org/pt-BR/demos/detail/old-radio/launch" target="_blank"><img class="botao" src="http://media.tumblr.com/tumblr_lk325lvHwF1qe3219.png"/></a> <a href="https://github.com/HTML5-Pro/oldRadio/" target="_blank"><img class="botao" src="http://media.tumblr.com/tumblr_lk325u7HMG1qe3219.png"/></a></p>

<p>Nos dois últimos eventos que nós (Zeno Rocha e Bernard de Luna) estivemos presentes (TDC 2012&#160;em São Paulo e Front in BH em Minas Gerais), fizemos questão de apresentar nosso primeiro experimento juntos, o <a href="https://developer.mozilla.org/pt-BR/demos/detail/old-radio/launch" target="_blank">Old Radio</a>, que figura hoje na galeria <a href="https://developer.mozilla.org/pt-BR/demos/detail/old-radio/launch" target="_blank">Mozilla Demo Studios</a>.</p>

<p>Infelizmente o outro criador Zanoni Miranda não pode estar presente, mas sua presença na equipe foi importantíssima e sempre fizemos questão de citá-lo.</p>

<p>Muitas pessoas nos abordaram com perguntas sobre como fizemos funcionalidade X ou Y, por isso hoje vamos passar pela produção desde o CSS até o JavaScript.</p>

<!-- more -->

<p><img src="http://media.tumblr.com/tumblr_m6wx0uXPdG1qe3219.jpg"/></p>

<hr><h2>Marcação e Estilização</h2>

<p>Para criar a marcação HTML do Old Radio, o Bernard De Luna seguiu o mesmo conceito de modularização. Ou seja, seguindo heranças de profundidades entre os itens, estilização baseada em classes e não em heranças, e por fim, nome de classes focadas nas funcionalidades reais. A ideia foi seguir a mesma estratégia usada para a criação do <a href="https://developer.mozilla.org/pt-BR/demosdetail/pure-css3-homer" target="_blank">Homer Simpsons</a>. Para ilustrar isso, segue o código de como foi feito a chave de desligar e ligar o rádio:</p>

<pre class="prettyprint lang-css">&lt;div class="power"&gt;
  &lt;span class="on-off active"&gt;
    &lt;a href="#" title="on / off"&gt;&lt;span&gt;on / off&lt;/span&gt;&lt;/a&gt;
  &lt;/span&gt;
&lt;/div&gt;

</pre>

<p>Trabalhar com uma boa hierarquia nos dá a capacidade de usar um conceito nativo do DOM que é a máscara. Ou seja, podemos ativar ou não através do “position” o limite da largura do pai em relação ao filho. Isso foi amplamente utilizado no Old Radio, principalmente quando chegamos ao visor.<br/><br/>A partir daí seguimos um outro conceito que poucos ainda utilizam quando se trata de CSS3, a combinação do RGBa. Assim fizemos algumas aplicações, mostradas abaixo:</p>

<p><img src="http://media.tumblr.com/tumblr_m7f6uqMHa21qe3219.jpg"/><br/><br/>O degradê que utilizamos para fazer o Efeito de Dourado foi o mesmo utilizado para criar o conceito de profundidade entre o case do rádio, ou seja, sempre pegando a cor marrom, amarela, preta, o que for e escurecendo em degradê. É uma ótima utilização do RGBa e ainda tem uma outra vantagem, que não foi utilizada nesse projeto, mas que vale a dica: as animações CSS funcionam para “background-color”, mas não imagem, pelo degradê renderizar como se fosse “background-image”, ele acaba não sendo animado. A partir do momento que o degradê inclui opacidade, você pode alterar apenas as cores, funcionando o transition e animation. Legal né?<br/><br/>O que trás a ideia de realidade para o projeto é puramente percepção, assim sendo, foram feitas algumas pesquisas referenciais de um rádio velho, ajudou muito ma hora de achar o tom das cores e estilo que seria desenhado. Confiram algumas das referências usadas:</p>

<p><img src="http://media.tumblr.com/tumblr_m7f6wvX31O1qe3219.jpg"/><br/><br/>Mas sem dúvida a que norteou todo o projeto, com cores, estilo foi essa imagem abaixo:</p>

<p><img src="http://media.tumblr.com/tumblr_m7f6xz24WI1qe3219.jpg"/><br/><br/>Através dessa referência, pudemos pegar o tom de cor da madeira e do dourado. Comparando com o Old Radio, fica bem claro a importância dessa referência pela palheta que indica a estação, o STEREO e o estilo do Tunner. Dessa referência fomos direto para o código, sem nenhum protótipo, nem layout em PSD.<br/><br/>Vale lembrar que o Old Radio surgiu logo após a ideia do Bernard De Luna de ter criado o Homer Simpsons só com CSS, para quem não conhece, ficou assim:<br/><a href="https://developer.mozilla.org/pt-BR/demosdetail/pure-css3-homer" target="_blank"><img src="http://media.tumblr.com/tumblr_m7f713gTC71qe3219.jpg"/></a><br/><br/>Se o De Luna, Bernard, Bê, rei, absoluto, lindo, desculpem, me emocionei&#8230;, bom, se ele seguisse a risca o modelo de estilização utilizado no Homer, muito provavelmente o Old Radio ficasse assim:</p>

<p><img src="http://media.tumblr.com/tumblr_m7f71xL0q31qe3219.jpg"/><br/><br/>Ficaria bonito, mas sem peso, sem realismo, novamente o RGBa aplicado em &#8220;box-shadow&#8221;, &#8220;gradient&#8221;, &#8220;text-shadow&#8221;, &#8220;border&#8221; e &#8220;background&#8221; foram responsáveis pelo tom de profundidade, textura e realismo esperado e atingido no Old Radio.<br/><br/>Por fim, vale explicar duas texturas utilizadas no rádio que fogem um pouco da aplicação normal, através do &#8220;repeating-linear-gradient&#8221;.</p>

<hr><h2>Textura de madeira</h2>

<p>Para fazer a textura de madeira, utilizamos a seguinte expressão:</p>

<pre class="prettyprint lang-css">repeating-linear-gradient(-90deg, <br/>rgba(0,0,0,0.1), rgba(0,0,0,0.1) 1px, transparent 3px);</pre>

<p>Ainda é uma renderização bastante bugada em browsers, mas mesmo com pequenas distorções ou o que renderizar, daria um ruído no marrom, mantendo a impressão da madeira desejada.</p>

<p><img src="http://media.tumblr.com/tumblr_m7f7lw4bwO1qe3219.jpg"/><br/><br/></p>

<hr><h2>Estações da rádio</h2>

<p>As estações dentre todos os objetos e dificuldades para se desenhar o Rádio foi a que mais me satisfez, pois não fazia ideia como conseguir atingir os &#8220;palitos&#8221; da frequência, o CSS me mostrou estar mais adiantado do que eu imaginava e consegui fazer isso com uma única marcação HTML e utilizando o &#8220;linear-gradient&#8221; combinado com o &#8220;background-size&#8221;.</p>

<pre class="prettyprint lang-css">background-image: linear-gradient(0, rgba(255,255,255,1) 1px, transparent 1px),<br/>linear-gradient(0, rgba(255,255,255,.3) 1px, transparent 1px);<br/>background-size: 25px 50px, 5px 5px;<br/>background-position:-24px bottom, -24px bottom;<br/>background-repeat: repeat-x;</pre>

<p>Vamos explicar rapidamente:</p>

<pre class="prettyprint lang-css">linear-gradient(0, rgba(255,255,255,1) 1px, transparent 1px)</pre>

<p>Estou usando degradê do branco para o transparente (sendo 1px para o branco e 1px para o transparente).</p>

<pre class="prettyprint lang-css">linear-gradient(0, rgba(255,255,255,.3) 1px, transparent 1px)</pre>

<p>Estou usando outro degradê do branco com 30% de transparencia para o transparente (sendo 1px para o branco e 1px para o transparente).<br/><br/>Agora vem a mágica, eu aplico &#8220;background-size&#8221; para manipular o tamanho desses degradês, dizendo que o primeiro ocupa 25px de largura e 50px de altura, enquanto o segundo ocupa 5px e 5px. O interessante é a conta feita, pois assim eu garanto que a cada 5 palitos brancos de 30% apareça 1 palito branco 100%. Reparem no desenho:</p>

<p><img src="http://media.tumblr.com/tumblr_m7f74aoSDw1qe3219.jpg"/><br/><br/>Por fim, desloquei os degradês 24px para esquerda para poder marcar o começo das estações com o primeiro palito, e alinhei verticalmente &#8220;bottom&#8221;. Finalizando com um &#8220;repeat-x&#8221; para que os traços se repitam e temos essa lindeza aí:</p>

<p><img src="http://media.tumblr.com/tumblr_m7f75yc6pz1qe3219.jpg"/><br/><br/>Só faltava fazê-lo funcionar não é verdade? Sente como fizemos isso&#8230;</p>

<hr><h2>HTML5 Audio API</h2>

<p>Para colocar o rádio para tocar, nada de Flash! Usamos a API de áudio do HTML5. A lista de músicas foi criada dinâmicamente e então utilizamos as funções da API para manipularmos os eventos de play/pause e aumentar/diminuir o volume do som.</p>

<hr><h2>jQuery vs YUI</h2>

<p>No início do projeto optamos pelo jQuery para manipular elementos do DOM de maneira mais simples, porém os recentes estudos que o Zeno estava fazendo em cima do YUI no dia anterior ao lançamento fizeram com que, em uma manhã de sábado na qual tinha viajado para São Paulo, lhe desse a louca de reescrever tudo usando YUI. <br/><br/>Apesar de volumosa, realizar essa mudança não foi dramático. Um guia em especial o ajudou nessa missão: <a href="http://www.jsrosettastone.com/" target="_blank">jQuery - YUI3 Rosseta Stone</a>.<br/><br/>Vale ressaltar que essa decisão não teve nada a ver com algum benefício que o YUI tem sobre o jQuery (que por sinal são muitos), até porque o único módulo usado para isso foi o &#8220;node&#8221; do YUI que realiza as mesmas coisas que o jQuery. Foi apenas curiosidade.</p>

<hr><h2>Konami Code</h2>

<p>Uma das brincadeiras que resolvemos aplicar foi uma surpresa para aqueles que fizessem o famoso Konami Code, macete conhecido dos nerds nos jogos antigos para arcade.<br/><br/>Depois de ter reescrito tudo em YUI, Zeno se deparou que ainda faltava uma coisa, o plugin de jQuery para ativar o Konami Code. Por sorte reescrever a lógica do plugin foi igualmente simples, até porque basta detectar uma sequência de caracteres. Dias depois do lançamento veio uma <a href="https://github.com/html5-pro/oldRadio/pull/3" target="_blank">contribuição legal</a> de Djalma Araújo movendo para um módulo de YUI toda a lógica do Konami Code.<br/><br/>Para ativar, digite:</p>

<pre class="prettyprint">cima + cima + baixo + baixo + esquerda + direita + esquerda + direita + b + a</pre>

<p>E voilà!</p>

<p><img src="http://media.tumblr.com/tumblr_m7f7t7to9w1qe3219.jpg"/></p>

<hr><h2>Cálculos e mais cálculos</h2>

<p>Uma dos principais desafios foram as questões matemáticas que envolvem a lógica do Player. Isso muitas vezes pode passar despercebido para as pessoas, mas pare para passar como você faria para aumentar e diminuir o volume do chiado à medida que o Tunner é rotacionado?</p>

<p>Para essa e outras questões, Zanoni utilizou vários conceitos matemáticos.<br/><br/>Basicamente o processo de rotação do tunner usa a lógica de <em>&#8220;Pressiona&#8221; -&gt; &#8220;Arrasta&#8221; -&gt; &#8220;Solta&#8221;</em>, onde no evento de <em>&#8220;Pressiona&#8221;</em> guardamos o valor que servirá de referência para a alteração do atributo que queremos modificar, nesse caso o ângulo do tunner. No <em>&#8220;Arrasta&#8221;</em> é onde iremos obter a diferença entre o valor inicial que recebemos no <em>&#8220;Pressiona&#8221;</em> e o obtido agora, e então faremos uma alteração baseada nessa diferença. E por fim, no <em>&#8220;Solta&#8221;</em> é onde finalizaremos esse processo.</p>

<p><br/><img src="http://media.tumblr.com/tumblr_m7f7vi8C691qe3219.jpg"/><br/><br/>O &#8220;Pressiona&#8221; é um evento para detectar quando pressionarem o mouse sobre o tunner. Quando ele for disparado, o ângulo entre a posição do mouse e o centro do botão do tunner é calculado:<br/><span class="Apple-tab-span"> </span></p>

<pre class="prettyprint lang-css">angulo = Math.atan2( tunerCenterY - MouseY , tunerCenterX - MouseX );</pre>

<p>A função atan2 retorna um ângulo em radianos de um vetor dado os valores dos componentes y e x desse vetor.</p>

<p><img src="http://media.tumblr.com/tumblr_m7f7wcZ4wE1qe3219.jpg"/><br/><br/>Mas esse ângulo é retornado em radianos, para converter de radianos em graus, usamos:</p>

<pre class="prettyprint">anguloGraus =  anguloRadianos * ( 180/Math.PI );</pre>

<p>Então guardamos esse ângulo para ser a referência do valor inicial da sequência <br/><em>&#8220;Pressiona&#8221; -&gt; &#8220;Arrasta&#8221; -&gt; &#8220;Solta&#8221;.</em><br/><br/>O <em>&#8220;Arrasta&#8221;</em> é um evento que será chamado se o mouse mover sobre o tunner, quando esse evento for disparado iremos calcular o ângulo entre a posição do mouse e o centro do botão do tunner novamente, e veremos a diferença entre o ângulo inicial obtido no &#8220;pressiona&#8221; e o obtido agora.<br/><br/>A partir desse valor podemos rotacionar o tunner e também alterar a estação da rádio, movendo o ponteiro das estações.</p>

<p><img src="http://media.tumblr.com/tumblr_m7f80zCZpS1qe3219.jpg"/><br/><br/>No caso da troca de estações queríamos que tivesse um efeito mais realista, para isso teria um ruído que apareceria e sumiria gradativamente entre uma estação e outra, para fazer esse efeito teríamos que obter 3 valores, o número da estação atual, o volume dessa estação e o volume do chiado. Esse valores teriam que ser calculados baseados na posição do ponteiro das estações.<br/><br/>Como fazemos isso?<br/><br/>Primeiro precisamos calcular a estação que está tocando no momento, usando a fórmula:</p>

<pre class="prettyprint">numeroCanal = Math.round( ( posicaoPonteiro / larguraDoMostrador ) * ( numeroDeCanais - 1 ) );</pre>

<p>Explicando melhor:</p>

<pre class="prettyprint">( posicaoPonteiro / larguraDoMostrador )</pre>

<p>Serve para saber a posição do ponteiro em relação ao tamanho do mostrador, ou seja em que porcentagem o ponteiro se encontra.</p>

<pre class="prettyprint">( numeroDeCanais - 1 )</pre>

<p>Porque o primeiro canal é 0.</p>

<pre class="prettyprint">Math.round</pre>

<p>É a função que arredonda um número para o inteiro mais próximo ( ex: Math.round(2.3) = 2 ,Math.round(2.8) = 3 ), isso porque o número do canal é um inteiro e não um float.</p>

<p><img src="http://media.tumblr.com/tumblr_m7f823B33Y1qe3219.jpg"/><br/><br/>Agora queremos saber o valor do volume do chiado e do som da estação, para obter a trasição gradativa usamos a função do coseno (Math.cos), a função do coseno gera uma ondulação que é exatamente o que queremos:</p>

<pre class="prettyprint">Valor =  Math.cos( ( posicaoPonteiro / larguraDoMostrador ) * ( numeroDeCanais - 1 ) * Math.PI * 2 ); </pre>

<p>Explicando melhor:</p>

<pre class="prettyprint">( posicaoPonteiro / larguraDoMostrador ) * ( numeroDeCanais - 1 )</pre>

<p>Tem o mesmo objetivo da fórmula anterior, porém agora sem arredondar.</p>

<pre class="prettyprint">Math.PI * 2</pre>

<p>Multiplicamos o o valor por 2*Pi porque a Math.cos recebe como parâmetro um ângulo em radiano e a função coseno forma um ciclo a cada 2*Pi. Como nós queremos que a função gere um ciclo para cada canal temos que multiplicar por 2*PI<br/><br/>Esse Valor é a posição da ondulação baseado nos nossos canais, mas esse valor varia entre -1 e 1, como não existe volume negativo temos que fazer um ajuste:</p>

<pre class="prettyprint">volumeCanal = Valor * 0.5 + 0.5;</pre>

<p>Com essa conta, o resultado varia de 0 a 1 e podemos usar como o volume do canal.<br/><br/>E volume do ruido é bem simples é o inverso do volume do canal. Por exemplo, se o canal está tocando à 90% de som, você completa o restante com ruído, ou seja 10%, se o canal esta tocando à 30%, o ruído vai estar à 70%.</p>

<pre class="prettyprint">volumeRuido = 1 - volumeCanal;</pre>

<p><img src="http://media.tumblr.com/tumblr_m7f83d4E9o1qe3219.jpg"/></p>

<hr><h2>Concluindo</h2>

<p>Esse projeto só está começando, a ideia é evoluir ele ainda mais utilizando recursos como Node.JS e integração com serviços como Twitter e Soundcloud. Tudo isso por um simples motivo: diversão.</p>
